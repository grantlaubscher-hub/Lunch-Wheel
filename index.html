<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lunch Wheel</title>

  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 24px; max-width: 980px; margin-inline: auto; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .row { display: grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 900px) { .row { grid-template-columns: 420px 1fr; align-items: start; } }

    .card { border: 1px solid #e5e7eb; border-radius: 14px; padding: 14px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    label { display: block; font-size: 12px; opacity: .8; margin-bottom: 6px; }
    input, select, button {
      width: 100%; box-sizing: border-box; padding: 10px 12px; border-radius: 10px;
      border: 1px solid #d1d5db; font-size: 14px;
    }
    button { cursor: pointer; border: 1px solid #111827; background: #111827; color: white; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .btnrow { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .small { font-size: 12px; opacity: .7; line-height: 1.4; }
    .status { font-size: 13px; }
    .ok { color: #065f46; }
    .warn { color: #92400e; }
    .err { color: #991b1b; }

    .wheelwrap { display: grid; gap: 10px; justify-items: center; }
    canvas { width: 360px; height: 360px; border-radius: 999px; border: 1px solid #e5e7eb; }
    .pointer {
      width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent;
      border-bottom: 18px solid #111827; margin-bottom: -10px;
    }

    .result { width: 100%; text-align: center; }
    .result a {
      color: #2563eb; font-size: 22px; font-weight: 700; text-decoration: none;
    }
    .result a:hover { text-decoration: underline; }
    .links a { display: inline-block; margin-top: 6px; font-size: 14px; }

    .list { max-height: 260px; overflow: auto; padding-left: 18px; width: 100%; }
    .list li { margin-bottom: 6px; font-size: 13px; }
    code { background: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>

<body>
  <h1>Lunch Wheel üçî</h1>
  <div class="small">Random takeaway spinner near 260 Queen Street.</div>

  <div class="row" style="margin-top:14px;">
    <div class="card">
      <label>Office address</label>
      <input id="addr" value="260 Queen Street, Brisbane City QLD 4000, Australia" />

      <div class="btnrow" style="margin-top:10px;">
        <select id="radius">
          <option value="500" selected>500m radius (default)</option>
          <option value="750">750m radius</option>
          <option value="1000">1km radius</option>
          <option value="1500">1.5km radius</option>
          <option value="2000">2km radius</option>
        </select>
        <button id="load">Load venues</button>
      </div>

      <div id="status" class="status warn" style="margin-top:10px;">
        Load venues to begin
      </div>

      <button id="spin" disabled style="margin-top:10px;">
        Spin üéØ
      </button>

      <div class="small" style="margin-top:10px;">
        If Overpass times out (504), this app will auto-retry on a mirror endpoint.
      </div>
    </div>

    <div class="card wheelwrap">
      <div class="pointer"></div>
      <canvas id="wheel" width="720" height="720"></canvas>

      <div id="picked" class="result small">Nothing picked yet</div>
      <div id="links" class="links"></div>

      <div class="small" style="width:100%;"><strong>Loaded venues</strong></div>
      <ol id="venueList" class="list"></ol>
    </div>
  </div>

<script>
  const NOMINATIM = "https://nominatim.openstreetmap.org/search";

  // Multiple public Overpass endpoints (mirrors) to reduce 504 pain.
  const OVERPASS_ENDPOINTS = [
    "https://overpass-api.de/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter",
    "https://overpass.nchc.org.tw/api/interpreter"
  ];

  const els = {
    addr: document.getElementById("addr"),
    radius: document.getElementById("radius"),
    load: document.getElementById("load"),
    spin: document.getElementById("spin"),
    status: document.getElementById("status"),
    wheel: document.getElementById("wheel"),
    picked: document.getElementById("picked"),
    links: document.getElementById("links"),
    venueList: document.getElementById("venueList"),
  };

  let venues = [];
  let currentAngle = 0;
  let spinning = false;

  function setStatus(msg, cls="warn") {
    els.status.className = "status " + cls;
    els.status.textContent = msg;
  }

  async function geocodeAddress(address) {
    const url = `${NOMINATIM}?q=${encodeURIComponent(address)}&format=json&limit=1`;
    const res = await fetch(url, { headers: { "Accept": "application/json" } });
    if (!res.ok) throw new Error(`Geocode failed (${res.status})`);
    const data = await res.json();
    if (!data.length) throw new Error("Address not found. Try a more specific address.");
    return { lat: +data[0].lat, lon: +data[0].lon };
  }

  // Lighter query than before:
  // - Use a single union per type group (still node/way/relation).
  // - Keep strict takeaway/takeout.
  // - Exclude cuisine that looks like juice/smoothie bars.
  function overpassQuery(lat, lon, r) {
    const EXCL = "juice|smoothie";

    return `
      [out:json][timeout:25];
      (
        nwr(around:${r},${lat},${lon})[amenity="fast_food"][cuisine!~"${EXCL}"];

        nwr(around:${r},${lat},${lon})[amenity~"^(restaurant|cafe)$"][takeaway~"^(yes|only)$"][cuisine!~"${EXCL}"];
        nwr(around:${r},${lat},${lon})[amenity~"^(restaurant|cafe)$"][takeout~"^(yes|only)$"][cuisine!~"${EXCL}"];
      );
      out center tags;
    `;
  }

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  async function postOverpassWithRetry(query, endpointLabel) {
    // Retry policy: try up to 2 attempts per endpoint, then move on
    const maxAttempts = 2;

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      const ctrl = new AbortController();
      const timeout = setTimeout(() => ctrl.abort(), 28000); // hard timeout client-side

      try {
        const res = await fetch(endpointLabel, {
          method: "POST",
          headers: {
            "Content-Type": "text/plain;charset=UTF-8",
            "Accept": "application/json"
          },
          body: query,
          signal: ctrl.signal
        });

        clearTimeout(timeout);

        // Overpass overloads: 429, 504, 502, 503 are common.
        if (!res.ok) {
          const retryable = [429, 502, 503, 504].includes(res.status);
          if (retryable && attempt < maxAttempts) {
            await sleep(800 * attempt);
            continue;
          }
          throw new Error(`Overpass failed ${res.status} (${endpointLabel})`);
        }

        return await res.json();
      } catch (err) {
        clearTimeout(timeout);

        // Abort or network error: treat as retryable
        const isAbort = err && (err.name === "AbortError");
        if ((isAbort || err instanceof TypeError) && attempt < maxAttempts) {
          await sleep(800 * attempt);
          continue;
        }

        // If final attempt fails, rethrow
        throw err;
      }
    }
  }

  async function fetchVenues(lat, lon, r) {
    const q = overpassQuery(lat, lon, r);

    // Try each endpoint in order
    let data = null;
    let lastErr = null;

    for (const endpoint of OVERPASS_ENDPOINTS) {
      try {
        setStatus(`Querying Overpass‚Ä¶ (${new URL(endpoint).host})`, "warn");
        data = await postOverpassWithRetry(q, endpoint);
        break;
      } catch (e) {
        lastErr = e;
      }
    }
    if (!data) throw lastErr || new Error("Overpass failed");

    const out = [];
    for (const e of (data.elements || [])) {
      const name = e.tags && e.tags.name;
      if (!name) continue;

      const lat2 = (typeof e.lat === "number") ? e.lat : (e.center && e.center.lat);
      const lon2 = (typeof e.lon === "number") ? e.lon : (e.center && e.center.lon);
      if (typeof lat2 !== "number" || typeof lon2 !== "number") continue;

      out.push({ name, lat: lat2, lon: lon2 });
    }

    // Deduplicate
    const seen = new Set();
    const dedup = [];
    for (const v of out) {
      const key = `${v.name}::${v.lat.toFixed(5)}::${v.lon.toFixed(5)}`;
      if (seen.has(key)) continue;
      seen.add(key);
      dedup.push(v);
    }

    // Shuffle
    for (let i = dedup.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [dedup[i], dedup[j]] = [dedup[j], dedup[i]];
    }

    return dedup;
  }

  function drawWheel() {
    const ctx = els.wheel.getContext("2d");
    const W = els.wheel.width;
    const cx = W / 2, cy = W / 2;
    const r = W / 2 - 12;

    ctx.clearRect(0, 0, W, W);

    // Background circle
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.fillStyle = "#ffffff";
    ctx.fill();
    ctx.strokeStyle = "#e5e7eb";
    ctx.lineWidth = 2;
    ctx.stroke();

    if (!venues.length) {
      ctx.fillStyle = "#6b7280";
      ctx.font = "28px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Load venues", cx, cy);
      return;
    }

    const n = venues.length;
    const slice = (Math.PI * 2) / n;

    for (let i = 0; i < n; i++) {
      const a0 = currentAngle + i * slice;
      const a1 = a0 + slice;

      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, r, a0, a1);
      ctx.closePath();
      ctx.fillStyle = (i % 2 === 0) ? "#f3f4f6" : "#e5e7eb";
      ctx.fill();

      ctx.strokeStyle = "#ffffff";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Label
      const mid = (a0 + a1) / 2;
      const tx = cx + Math.cos(mid) * (r * 0.62);
      const ty = cy + Math.sin(mid) * (r * 0.62);

      ctx.save();
      ctx.translate(tx, ty);
      ctx.rotate(mid);
      ctx.fillStyle = "#111827";
      ctx.font = "16px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const label = venues[i].name.length > 18 ? venues[i].name.slice(0, 17) + "‚Ä¶" : venues[i].name;
      ctx.fillText(label, 0, 0);
      ctx.restore();
    }

    // Center cap
    ctx.beginPath();
    ctx.arc(cx, cy, 42, 0, Math.PI * 2);
    ctx.fillStyle = "#111827";
    ctx.fill();
  }

  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  function spinWheel(durationMs = 3000) {
    if (spinning || venues.length < 2) return;

    spinning = true;
    els.spin.disabled = true;
    els.load.disabled = true;
    els.picked.textContent = "Spinning‚Ä¶";
    els.links.innerHTML = "";

    const start = performance.now();
    const startAngle = currentAngle;

    const rotations = 5 + Math.random() * 2; // 5‚Äì7 turns
    const endAngle = startAngle + rotations * Math.PI * 2;

    function frame(now) {
      const t = Math.min((now - start) / durationMs, 1);
      currentAngle = startAngle + (endAngle - startAngle) * easeOutCubic(t);
      drawWheel();

      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        spinning = false;
        els.spin.disabled = false;
        els.load.disabled = false;

        const pick = venues[Math.floor(Math.random() * venues.length)];
        const mapsUrl =
          `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(pick.name)}@${pick.lat},${pick.lon}`;

        els.picked.innerHTML = `<a href="${mapsUrl}" target="_blank" rel="noopener noreferrer">${pick.name}</a>`;
        els.links.innerHTML = `
          <a href="https://www.google.com/maps/dir/?api=1&destination=${pick.lat},${pick.lon}&travelmode=walking"
             target="_blank" rel="noopener noreferrer">
            Walking directions
          </a>
        `;
      }
    }

    requestAnimationFrame(frame);
  }

  els.load.onclick = async () => {
    try {
      els.load.disabled = true;
      els.spin.disabled = true;

      setStatus("Geocoding address‚Ä¶", "warn");
      const { lat, lon } = await geocodeAddress(els.addr.value);

      const r = parseInt(els.radius.value, 10);
      setStatus(`Fetching venues within ${r}m‚Ä¶`, "warn");

      venues = await fetchVenues(lat, lon, r);

      drawWheel();
      els.venueList.innerHTML = venues.map(v => `<li>${v.name}</li>`).join("");

      if (!venues.length) {
        setStatus("No venues found (strict takeaway + juice exclusion). Try 750m or 1km.", "err");
        els.picked.textContent = "Nothing picked yet";
        els.links.innerHTML = "";
        return;
      }

      setStatus(`Loaded ${venues.length} venues`, "ok");
      els.spin.disabled = (venues.length < 2);
      els.picked.textContent = "Ready. Hit Spin üéØ";
      els.links.innerHTML = "";
    } catch (e) {
      setStatus(e.message || String(e), "err");
    } finally {
      els.load.disabled = false;
    }
  };

  els.spin.onclick = () => spinWheel(3000);
  drawWheel();
</script>
</body>
</html>
