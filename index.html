<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Lunch Wheel</title>

  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; padding: 24px; max-width: 980px; margin-inline: auto; }
    h1 { margin: 0 0 6px; font-size: 22px; }
    .row { display: grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 900px) { .row { grid-template-columns: 420px 1fr; align-items: start; } }

    .card { border: 1px solid #e5e7eb; border-radius: 14px; padding: 14px; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    label { display: block; font-size: 12px; opacity: .8; margin-bottom: 6px; }
    input, select, button {
      width: 100%; box-sizing: border-box; padding: 10px 12px; border-radius: 10px;
      border: 1px solid #d1d5db; font-size: 14px;
    }
    button { cursor: pointer; border: 1px solid #111827; background: #111827; color: white; }
    button:disabled { opacity: .5; cursor: not-allowed; }

    .btnrow { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .small { font-size: 12px; opacity: .7; line-height: 1.4; }
    .status { font-size: 13px; }
    .ok { color: #065f46; }
    .warn { color: #92400e; }
    .err { color: #991b1b; }

    .wheelwrap { display: grid; gap: 10px; justify-items: center; }
    canvas { width: 360px; height: 360px; border-radius: 999px; border: 1px solid #e5e7eb; background: transparent; }
    .pointer {
      width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent;
      border-bottom: 18px solid #111827; margin-bottom: -10px;
    }

    .result { width: 100%; text-align: center; }
    .result a { color: #2563eb; font-size: 22px; font-weight: 700; text-decoration: none; }
    .result a:hover { text-decoration: underline; }
    .links a { display: inline-block; margin-top: 6px; font-size: 14px; }

    .list { max-height: 260px; overflow: auto; padding-left: 18px; width: 100%; }
    .list li { margin-bottom: 6px; font-size: 13px; }
    code { background: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>

<body>
  <h1>Lunch Wheel üçä</h1>
  <div class="small">
    Default radius <strong>500m</strong> from 260 Queen Street.
    <br/>
    Includes restaurant/cafe with <code>cuisine=*</code> (helps missing-takeaway-tag venues).
    Excludes obvious juice bars again (name contains ‚Äújuice‚Äù, or <code>amenity=juice_bar</code>, or <code>shop=juice</code>).
    De-duped by venue name.
  </div>

  <div class="row" style="margin-top:14px;">
    <div class="card">
      <label>Office address</label>
      <input id="addr" value="260 Queen Street, Brisbane City QLD 4000, Australia" />

      <div class="btnrow" style="margin-top:10px;">
        <select id="radius">
          <option value="500" selected>500m radius (default)</option>
          <option value="750">750m radius</option>
          <option value="1000">1km radius</option>
          <option value="1500">1.5km radius</option>
          <option value="2000">2km radius</option>
        </select>
        <button id="load">Load venues</button>
      </div>

      <div id="status" class="status warn" style="margin-top:10px;">Load venues to begin</div>
      <button id="spin" disabled style="margin-top:10px;">Spin üéØ</button>
    </div>

    <div class="card wheelwrap">
      <div class="pointer"></div>
      <canvas id="wheel" width="720" height="720"></canvas>

      <div id="picked" class="result small">Nothing picked yet</div>
      <div id="links" class="links"></div>

      <div class="small" style="width:100%;"><strong>Loaded venues</strong></div>
      <ol id="venueList" class="list"></ol>
    </div>
  </div>

<script>
  const NOMINATIM = "https://nominatim.openstreetmap.org/search";
  const OVERPASS_ENDPOINTS = [
    "https://overpass-api.de/api/interpreter",
    "https://overpass.kumi.systems/api/interpreter",
    "https://overpass.nchc.org.tw/api/interpreter"
  ];

  const els = {
    addr: document.getElementById("addr"),
    radius: document.getElementById("radius"),
    load: document.getElementById("load"),
    spin: document.getElementById("spin"),
    status: document.getElementById("status"),
    wheel: document.getElementById("wheel"),
    picked: document.getElementById("picked"),
    links: document.getElementById("links"),
    venueList: document.getElementById("venueList"),
  };

  let venues = [];
  let currentAngle = 0;
  let spinning = false;

  function setStatus(msg, cls="warn") {
    els.status.className = "status " + cls;
    els.status.textContent = msg;
  }

  function normalizeName(name) {
    return (name || "")
      .trim()
      .toLowerCase()
      .replace(/[‚Äô']/g, "")
      .replace(/[^a-z0-9\s]/g, " ")
      .replace(/\s+/g, " ");
  }

  function isJuiceBarLike(venue) {
    const n = normalizeName(venue.name);
    return n.includes("juice"); // keep smoothie-friendly cafes (no "smoothie" blocking)
  }

  async function geocodeAddress(address) {
    const url = `${NOMINATIM}?q=${encodeURIComponent(address)}&format=json&limit=1`;
    const res = await fetch(url, { headers: { "Accept": "application/json" } });
    if (!res.ok) throw new Error(`Geocode failed (${res.status})`);
    const data = await res.json();
    if (!data.length) throw new Error("Address not found. Try a more specific address.");
    return { lat: +data[0].lat, lon: +data[0].lon };
  }

  function overpassQuery(lat, lon, r) {
    return `
      [out:json][timeout:25];
      (
        nwr(around:${r},${lat},${lon})[amenity="fast_food"][amenity!="juice_bar"][shop!="juice"];

        nwr(around:${r},${lat},${lon})[amenity~"^(restaurant|cafe)$"][takeaway~"^(yes|only)$"][amenity!="juice_bar"][shop!="juice"];
        nwr(around:${r},${lat},${lon})[amenity~"^(restaurant|cafe)$"][takeout~"^(yes|only)$"][amenity!="juice_bar"][shop!="juice"];

        // include restaurant/cafe with cuisine=*
        nwr(around:${r},${lat},${lon})[amenity~"^(restaurant|cafe)$"][cuisine][amenity!="juice_bar"][shop!="juice"];
      );
      out center tags;
    `;
  }

  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  async function postOverpassWithRetry(query, endpointUrl) {
    const maxAttempts = 2;

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      const ctrl = new AbortController();
      const timeout = setTimeout(() => ctrl.abort(), 28000);

      try {
        const res = await fetch(endpointUrl, {
          method: "POST",
          headers: {
            "Content-Type": "text/plain;charset=UTF-8",
            "Accept": "application/json"
          },
          body: query,
          signal: ctrl.signal
        });

        clearTimeout(timeout);

        if (!res.ok) {
          const retryable = [429, 502, 503, 504].includes(res.status);
          if (retryable && attempt < maxAttempts) {
            await sleep(800 * attempt);
            continue;
          }
          throw new Error(`Overpass failed ${res.status} (${new URL(endpointUrl).host})`);
        }

        return await res.json();
      } catch (err) {
        clearTimeout(timeout);
        const isAbort = err && err.name === "AbortError";
        const isNetwork = err instanceof TypeError;

        if ((isAbort || isNetwork) && attempt < maxAttempts) {
          await sleep(800 * attempt);
          continue;
        }
        throw err;
      }
    }
  }

  async function fetchVenues(lat, lon, r) {
    const q = overpassQuery(lat, lon, r);

    let data = null;
    let lastErr = null;

    for (const endpoint of OVERPASS_ENDPOINTS) {
      try {
        setStatus(`Querying Overpass‚Ä¶ (${new URL(endpoint).host})`, "warn");
        data = await postOverpassWithRetry(q, endpoint);
        break;
      } catch (e) {
        lastErr = e;
      }
    }
    if (!data) throw (lastErr || new Error("Overpass failed"));

    const raw = [];
    for (const e of (data.elements || [])) {
      const name = e.tags && e.tags.name;
      if (!name) continue;

      const lat2 = (typeof e.lat === "number") ? e.lat : (e.center && e.center.lat);
      const lon2 = (typeof e.lon === "number") ? e.lon : (e.center && e.center.lon);
      if (typeof lat2 !== "number" || typeof lon2 !== "number") continue;

      raw.push({ name, lat: lat2, lon: lon2 });
    }

    // client-side remove "juice" by name
    const filtered = raw.filter(v => !isJuiceBarLike(v));

    // de-dupe by normalized name
    const byName = new Map();
    for (const v of filtered) {
      const key = normalizeName(v.name);
      if (!key) continue;
      if (!byName.has(key)) byName.set(key, v);
    }

    const dedup = Array.from(byName.values());

    // shuffle
    for (let i = dedup.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [dedup[i], dedup[j]] = [dedup[j], dedup[i]];
    }

    return dedup;
  }

  function updateVenueList() {
    els.venueList.innerHTML = venues.map(v => `<li>${v.name}</li>`).join("");
  }

  // ---- ORANGE WHEEL LOOK ----
  // We keep wedges for readability, but we overlay an "orange peel" look:
  // - orange radial gradient
  // - subtle peel texture dots
  // - segment "pith" lines
  // - small green leaf + stem at top
  function drawOrangeBase(ctx, cx, cy, radius) {
    // Orange peel gradient
    const g = ctx.createRadialGradient(cx - radius*0.25, cy - radius*0.25, radius*0.2, cx, cy, radius);
    g.addColorStop(0, "#ffd08a");
    g.addColorStop(0.55, "#ff8a00");
    g.addColorStop(1, "#d85a00");

    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = g;
    ctx.fill();

    // Peel texture (deterministic-ish dots)
    ctx.save();
    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.clip();

    // seedable pattern based on venue count so it doesn't "flicker" too much
    const dotCount = 260;
    for (let i = 0; i < dotCount; i++) {
      const a = (i * 0.6180339887) * Math.PI * 2; // golden-angle-ish
      const rr = Math.sqrt((i % dotCount) / dotCount) * radius;
      const x = cx + Math.cos(a) * rr;
      const y = cy + Math.sin(a) * rr;

      const d = 1 + (i % 3); // 1-3px
      ctx.fillStyle = (i % 2 === 0) ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.06)";
      ctx.beginPath();
      ctx.arc(x, y, d, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    // Outer rind
    ctx.strokeStyle = "rgba(90,30,0,0.22)";
    ctx.lineWidth = 10;
    ctx.beginPath();
    ctx.arc(cx, cy, radius - 2, 0, Math.PI * 2);
    ctx.stroke();

    // Inner highlight ring
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(cx, cy, radius - 14, 0, Math.PI * 2);
    ctx.stroke();
  }

  function drawLeaf(ctx, cx, cy, radius) {
    // Stem
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(-Math.PI / 2); // top
    const stemY = -radius + 20;

    ctx.strokeStyle = "#5b3a1a";
    ctx.lineWidth = 8;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(-6, stemY + 8);
    ctx.lineTo(-2, stemY - 10);
    ctx.stroke();

    // Leaf
    const lg = ctx.createLinearGradient(0, stemY - 25, 0, stemY + 15);
    lg.addColorStop(0, "#34d399");
    lg.addColorStop(1, "#15803d");

    ctx.fillStyle = lg;
    ctx.beginPath();
    ctx.ellipse(18, stemY - 10, 34, 18, -0.55, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "rgba(0,0,0,0.15)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.ellipse(18, stemY - 10, 34, 18, -0.55, 0, Math.PI * 2);
    ctx.stroke();

    // Leaf vein
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(4, stemY - 8);
    ctx.lineTo(34, stemY - 16);
    ctx.stroke();

    ctx.restore();
  }

  function drawWheel() {
    const ctx = els.wheel.getContext("2d");
    const W = els.wheel.width;
    const cx = W / 2, cy = W / 2;
    const radius = W / 2 - 12;

    ctx.clearRect(0, 0, W, W);

    // Orange base (always)
    drawOrangeBase(ctx, cx, cy, radius);

    if (!venues.length) {
      ctx.fillStyle = "rgba(17,24,39,0.75)";
      ctx.font = "28px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Load venues", cx, cy);
      drawLeaf(ctx, cx, cy, radius);
      return;
    }

    // Wedges overlay (subtle) so it still reads like a wheel
    const n = venues.length;
    const slice = (Math.PI * 2) / n;

    // Segment lines (pith)
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 4;

    for (let i = 0; i < n; i++) {
      const a = currentAngle + i * slice;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(a) * (radius - 20), cy + Math.sin(a) * (radius - 20));
      ctx.stroke();
    }
    ctx.restore();

    // Center pith circle
    ctx.beginPath();
    ctx.arc(cx, cy, 48, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(255,255,255,0.65)";
    ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.85)";
    ctx.lineWidth = 6;
    ctx.stroke();

    // Labels
    for (let i = 0; i < n; i++) {
      const a0 = currentAngle + i * slice;
      const a1 = a0 + slice;
      const mid = (a0 + a1) / 2;

      const tx = cx + Math.cos(mid) * (radius * 0.62);
      const ty = cy + Math.sin(mid) * (radius * 0.62);

      ctx.save();
      ctx.translate(tx, ty);
      ctx.rotate(mid);

      // readable label pill
      const label = venues[i].name.length > 18 ? venues[i].name.slice(0, 17) + "‚Ä¶" : venues[i].name;

      ctx.font = "16px system-ui";
      const m = ctx.measureText(label);
      const padX = 10, padY = 7;
      const bw = m.width + padX * 2;
      const bh = 22 + padY;

      ctx.fillStyle = "rgba(255,255,255,0.78)";
      ctx.strokeStyle = "rgba(0,0,0,0.10)";
      ctx.lineWidth = 2;

      ctx.beginPath();
      const x = -bw / 2, y = -bh / 2;
      const r = 10;
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + bw, y, x + bw, y + bh, r);
      ctx.arcTo(x + bw, y + bh, x, y + bh, r);
      ctx.arcTo(x, y + bh, x, y, r);
      ctx.arcTo(x, y, x + bw, y, r);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "#111827";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, 0, 0);

      ctx.restore();
    }

    // Leaf + stem
    drawLeaf(ctx, cx, cy, radius);
  }

  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  function spinWheel(durationMs = 3000) {
    if (spinning || venues.length < 1) return;

    spinning = true;
    els.spin.disabled = true;
    els.load.disabled = true;
    els.picked.textContent = "Spinning‚Ä¶";
    els.links.innerHTML = "";

    const start = performance.now();
    const startAngle = currentAngle;

    const rotations = 5 + Math.random() * 2;
    const endAngle = startAngle + rotations * Math.PI * 2;

    function frame(now) {
      const t = Math.min((now - start) / durationMs, 1);
      currentAngle = startAngle + (endAngle - startAngle) * easeOutCubic(t);
      drawWheel();

      if (t < 1) {
        requestAnimationFrame(frame);
      } else {
        spinning = false;
        els.spin.disabled = false;
        els.load.disabled = false;

        const pick = venues[Math.floor(Math.random() * venues.length)];
        const mapsUrl =
          `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(pick.name)}@${pick.lat},${pick.lon}`;

        els.picked.innerHTML =
          `<a href="${mapsUrl}" target="_blank" rel="noopener noreferrer">${pick.name}</a>`;

        els.links.innerHTML = `
          <a href="https://www.google.com/maps/dir/?api=1&destination=${pick.lat},${pick.lon}&travelmode=walking"
             target="_blank" rel="noopener noreferrer">
            Walking directions
          </a>
        `;
      }
    }

    requestAnimationFrame(frame);
  }

  els.load.onclick = async () => {
    try {
      els.load.disabled = true;
      els.spin.disabled = true;

      setStatus("Geocoding address‚Ä¶", "warn");
      const { lat, lon } = await geocodeAddress(els.addr.value);

      const r = parseInt(els.radius.value, 10);
      setStatus(`Fetching venues within ${r}m‚Ä¶`, "warn");

      venues = await fetchVenues(lat, lon, r);
      currentAngle = 0;

      updateVenueList();
      drawWheel();

      els.picked.textContent = "Ready. Hit Spin üéØ";
      els.links.innerHTML = "";

      if (!venues.length) {
        setStatus("No venues found. Try 750m or 1km.", "err");
        return;
      }

      setStatus(`Loaded ${venues.length} venues`, "ok");
      els.spin.disabled = false;
    } catch (e) {
      setStatus(e.message || String(e), "err");
    } finally {
      els.load.disabled = false;
    }
  };

  els.spin.onclick = () => spinWheel(3000);
  drawWheel();
</script>
</body>
</html>
